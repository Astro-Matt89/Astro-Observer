"""
Space Object — base class for every object in the universe.

Coordinate system:
  All objects are stored in equatorial J2000:
    ra_deg    : Right Ascension (0-360°)
    dec_deg   : Declination (-90 to +90°)
    distance_ly: Distance from Sun in light-years

  From these we derive Cartesian (x, y, z) in ly:
    x = d * cos(dec) * cos(ra)
    y = d * cos(dec) * sin(ra)
    z = d * sin(dec)

  The observer (observatory) is always at origin (0, 0, 0).

Object taxonomy:
  REAL      — from a real astronomical catalogue (always visible in chart)
  PROCEDURAL— generated by the engine (visible only after catalogued via imaging)
"""

from __future__ import annotations
import math
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Optional, Tuple


# ---------------------------------------------------------------------------
# Enums
# ---------------------------------------------------------------------------

class ObjectClass(Enum):
    """Top-level physical class"""
    STAR             = "star"
    NEBULA           = "nebula"
    GALAXY           = "galaxy"
    CLUSTER          = "cluster"
    COMPACT          = "compact"       # pulsar, black hole, neutron star
    SOLAR_SYSTEM     = "solar_system"  # planet, comet, asteroid
    UNKNOWN          = "unknown"


class ObjectSubtype(Enum):
    """Detailed subtype"""
    # Stars
    MAIN_SEQUENCE    = "main_sequence"
    GIANT            = "giant"
    SUPERGIANT       = "supergiant"
    WHITE_DWARF      = "white_dwarf"
    VARIABLE         = "variable"
    DOUBLE           = "double"

    # Nebulae
    EMISSION         = "emission"      # HII region
    REFLECTION       = "reflection"
    PLANETARY        = "planetary"
    SUPERNOVA_REMNANT= "snr"
    DARK             = "dark"
    PROTOSTELLAR     = "protostellar"

    # Galaxies
    SPIRAL           = "spiral"
    BARRED_SPIRAL    = "barred_spiral"
    ELLIPTICAL       = "elliptical"
    LENTICULAR       = "lenticular"
    IRREGULAR        = "irregular"
    DWARF            = "dwarf"
    ACTIVE           = "active"        # Seyfert, quasar

    # Clusters
    OPEN_CLUSTER     = "open_cluster"
    GLOBULAR_CLUSTER = "globular_cluster"
    GALAXY_CLUSTER   = "galaxy_cluster"

    # Compact
    PULSAR           = "pulsar"
    NEUTRON_STAR     = "neutron_star"
    BLACK_HOLE       = "black_hole"

    # Solar system
    PLANET           = "planet"
    DWARF_PLANET     = "dwarf_planet"
    COMET            = "comet"
    ASTEROID         = "asteroid"

    # Fallback
    UNKNOWN          = "unknown"


class ObjectOrigin(Enum):
    """Where this object came from"""
    REAL        = "real"        # Astronomical catalogue
    PROCEDURAL  = "procedural"  # Generated by engine


class DiscoveryState(Enum):
    """Player discovery state"""
    KNOWN       = "known"       # Real objects: always known
    CATALOGUED  = "catalogued"  # Procedural: player has imaged & catalogued it
    UNKNOWN     = "unknown"     # Procedural: not yet discovered


# ---------------------------------------------------------------------------
# SpaceObject
# ---------------------------------------------------------------------------

@dataclass
class SpaceObject:
    """
    Universal base class for every object in the simulated universe.

    Required fields
    ---------------
    uid        : unique string ID  e.g. "M42", "NGC7293", "PROC_0001"
    name       : human-readable name
    ra_deg     : Right Ascension J2000 (degrees)
    dec_deg    : Declination J2000 (degrees)
    distance_ly: distance from observer (light-years)
    obj_class  : ObjectClass enum
    subtype    : ObjectSubtype enum
    origin     : ObjectOrigin (REAL or PROCEDURAL)

    Optional physical fields
    ------------------------
    mag        : apparent visual magnitude
    size_arcmin: apparent major axis (arcminutes)
    size_minor_arcmin: apparent minor axis (arcminutes, 0 = circular)
    pa_deg     : position angle (degrees from North)
    bv_color   : B-V color index (stars)
    constellation: constellation name

    Derived (computed on demand)
    ----------------------------
    xyz_ly     : Cartesian position in ly (computed from ra/dec/dist)
    """

    # Identity
    uid:           str
    name:          str

    # Position (equatorial J2000)
    ra_deg:        float
    dec_deg:       float
    distance_ly:   float

    # Classification
    obj_class:     ObjectClass
    subtype:       ObjectSubtype
    origin:        ObjectOrigin = ObjectOrigin.REAL

    # Discovery (only matters for PROCEDURAL)
    discovery:     DiscoveryState = DiscoveryState.KNOWN

    # Physical properties
    mag:           float        = 0.0
    size_arcmin:   float        = 0.0
    size_minor_arcmin: float    = 0.0
    pa_deg:        float        = 0.0
    bv_color:      float        = 0.6   # Default: Sun-like
    constellation: str          = ""
    description:   str          = ""

    # Extra metadata (flexible dict for subtype-specific data)
    meta:          dict         = field(default_factory=dict)

    # -----------------------------------------------------------------------
    # Derived properties
    # -----------------------------------------------------------------------

    @property
    def xyz_ly(self) -> Tuple[float, float, float]:
        """Cartesian position in light-years (origin = Sun/observer)"""
        ra  = math.radians(self.ra_deg)
        dec = math.radians(self.dec_deg)
        d   = self.distance_ly
        x = d * math.cos(dec) * math.cos(ra)
        y = d * math.cos(dec) * math.sin(ra)
        z = d * math.sin(dec)
        return x, y, z

    @property
    def is_visible_in_chart(self) -> bool:
        """
        Should this object be visible in the Sky Chart?
        Real objects: always yes.
        Procedural: only if catalogued.
        """
        if self.origin == ObjectOrigin.REAL:
            return True
        return self.discovery == DiscoveryState.CATALOGUED

    @property
    def angular_size(self) -> Tuple[float, float]:
        """(major_arcmin, minor_arcmin)"""
        minor = self.size_minor_arcmin if self.size_minor_arcmin > 0 else self.size_arcmin
        return self.size_arcmin, minor

    # -----------------------------------------------------------------------
    # Convenience
    # -----------------------------------------------------------------------

    def distance_str(self) -> str:
        """Human-readable distance string"""
        d = self.distance_ly
        if d >= 1_000_000:
            return f"{d / 1_000_000:.2f} Mly"
        if d >= 1_000:
            return f"{d / 1000:.1f} kly"
        return f"{d:.1f} ly"

    def radec_str(self) -> str:
        """Human-readable RA/Dec string"""
        ra_h = int(self.ra_deg / 15)
        ra_m = int((self.ra_deg / 15 - ra_h) * 60)
        ra_s = int(((self.ra_deg / 15 - ra_h) * 60 - ra_m) * 60)
        sign = "+" if self.dec_deg >= 0 else "-"
        dd = int(abs(self.dec_deg))
        dm = int((abs(self.dec_deg) - dd) * 60)
        return f"RA {ra_h:02d}h{ra_m:02d}m{ra_s:02d}s  Dec {sign}{dd:02d}°{dm:02d}'"

    def __repr__(self) -> str:
        return f"<SpaceObject {self.uid} '{self.name}' {self.obj_class.value}/{self.subtype.value}>"
